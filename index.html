<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roleplay AI - Versão com Copiar/Colar</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body::before, body::after {
            content: ''; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: -2;
            background-size: cover; background-position: center; transition: opacity 1.5s ease-in-out;
        }
        body::before { background-image: var(--bg-image-before); opacity: 1; }
        body::after { background-image: var(--bg-image-after); opacity: 0; }
        body.show-after::before { opacity: 0; }
        body.show-after::after { opacity: 1; }
        
        .overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.3); z-index: -1; }
        .chat-container { height: calc(100vh - 400px); }
        .message-container { max-height: calc(100vh - 500px); }
        .typing-animation::after { content: '...'; animation: typing 1.5s infinite; }
        @keyframes typing { 0% { content: ''; } 25% { content: '.'; } 50% { content: '..'; } 75% { content: '...'; } }
        .image-fade { animation: imageFade 0.7s ease-in-out; }
        @keyframes imageFade { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- NOVO: Estilos para o Botão Copiar e Feedback --- */
        .copy-btn {
            background-color: #e2e8f0; /* gray-200 */
            color: #4a5568; /* gray-700 */
            border: 1px solid #cbd5e0; /* gray-400 */
            border-radius: 6px;
            padding: 2px 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .copy-btn:hover {
            background-color: #cbd5e0; /* gray-400 */
        }
        .copy-btn:disabled {
            background-color: #a0aec0; /* gray-500 */
            color: #f7fafc; /* gray-100 */
            cursor: default;
        }
        .copy-feedback {
            font-size: 12px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none; /* Evita que o texto de feedback seja clicável */
        }
        .copy-feedback.show {
            opacity: 1;
        }
    </style>
</head>
<body class="min-h-screen">
    <div class="overlay"></div>
    <div class="container mx-auto p-4 max-w-4xl">
        <!-- O HTML do cabeçalho, configurações e chat permanece o mesmo -->
        <header class="text-center mb-6">
            <h1 class="text-3xl font-bold text-white drop-shadow-lg">Roleplay AI</h1>
            <p class="text-gray-200 font-semibold drop-shadow-md">Com cenário dinâmico, memória e copiar/colar.</p>
        </header>
        <div class="bg-white/80 backdrop-blur-sm rounded-lg shadow-lg p-4 mb-4">
            <!-- (Conteúdo da Persona e Memória) -->
             <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center"><div><label class="block text-gray-700 font-bold mb-2">Persona Predefinida</label><select id="personaSelect" class="w-full p-2 border rounded"><option value="custom">Personalizada</option><option value="mago">Mago Arcano</option><option value="detetive">Detetive Noir</option><option value="elfo">Elfo da Floresta</option><option value="cientista">Cientista Maluco</option><option value="pirata">Capitão Pirata</option></select></div><div><label class="block text-gray-700 font-bold mb-2">Personalização Livre</label><textarea id="customPersona" class="w-full p-2 border rounded h-20 resize-none" placeholder="Descreva a personalidade do seu personagem..."></textarea></div></div><div class="flex justify-between items-center mt-4"><details><summary class="font-bold text-gray-700 cursor-pointer text-sm">Ver Memória de Longo Prazo</summary><p id="summaryDisplay" class="text-xs text-gray-600 mt-2 p-2 bg-gray-50 rounded italic"></p></details><button id="clearHistoryBtn" class="bg-red-500 text-white px-3 py-1 rounded text-sm hover:bg-red-600">Limpar Memória</button></div>
        </div>
        <div class="bg-white/80 backdrop-blur-sm rounded-lg shadow-lg chat-container">
            <div id="messageHistory" class="message-container p-4 overflow-y-auto space-y-4"></div>
            <div class="border-t p-4 bg-white/50">
                <form id="chatForm" class="flex gap-2"><input type="text" id="userInput" class="flex-1 p-2 border rounded" placeholder="Digite sua mensagem..." required autocomplete="off"><button type="submit" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Enviar</button></form>
            </div>
        </div>
    </div>

<script>
// --- 1. CONFIGURAÇÕES E ELEMENTOS ---
const bodyEl = document.querySelector('body');
const chatForm = document.getElementById('chatForm');
// ... (outros elementos)
const summaryDisplay = document.getElementById('summaryDisplay');
const predefinedPersonas = { /* ... (mesmo objeto de personas) ... */ };

// --- 2. GERENCIAMENTO DE ESTADO ---
let conversationHistory = [], conversationSummary = "", lastSummaryIndex = 0, lastBackgroundImageUrl = "", isBackgroundAfterActive = false;
// ... (funções saveState, loadState) ...

// --- 3. FUNÇÕES DE API E UTILITÁRIOS ---
async function fetchWithTimeout(resource, options = {}, timeout = 25000) { /* ... (código igual ao anterior) ... */ }
function updatePageBackground(imageUrl) { /* ... (código igual ao anterior) ... */ }
async function createImagePrompt(context) { /* ... (código igual ao anterior) ... */ }
function generateImageUrl(detailedPrompt) { /* ... (código igual ao anterior) ... */ }
async function playAudio(text) { /* ... (código igual ao anterior) ... */ }
async function updateSummary() { /* ... (código igual ao anterior) ... */ }

/**
 * NOVO: Função para copiar texto para a área de transferência
 * @param {HTMLButtonElement} buttonElement O elemento do botão que foi clicado.
 */
async function copyToClipboard(buttonElement) {
    const messageDiv = buttonElement.closest('.max-w-\\[80\\%\\]');
    const textToCopy = messageDiv.querySelector('p').innerText;
    const feedbackElement = messageDiv.querySelector('.copy-feedback');

    try {
        await navigator.clipboard.writeText(textToCopy);
        
        // Feedback de sucesso
        buttonElement.textContent = 'Copiado!';
        buttonElement.disabled = true;
        feedbackElement.textContent = 'Sucesso!';
        feedbackElement.style.color = '#2f855a'; // Verde
        feedbackElement.classList.add('show');

        // Reverte a aparência após 2 segundos
        setTimeout(() => {
            buttonElement.textContent = 'Copiar';
            buttonElement.disabled = false;
            feedbackElement.classList.remove('show');
        }, 2000);

    } catch (err) {
        console.error('Falha ao copiar texto: ', err);
        // Feedback de erro
        feedbackElement.textContent = 'Falha ao copiar!';
        feedbackElement.style.color = '#c53030'; // Vermelho
        feedbackElement.classList.add('show');
        
        // Esconde a mensagem de erro após 2 segundos
        setTimeout(() => {
            feedbackElement.classList.remove('show');
        }, 2000);
    }
}

// --- 4. RENDERIZAÇÃO E UI ---
function updateSummaryDisplay() { /* ... */ }

function renderMessage(messageObject) {
    const { content, isUser, generateImage, imagePrompt, imageUrl } = messageObject;
    const div = document.createElement('div');
    div.className = `flex flex-col ${isUser ? 'items-end' : 'items-start'}`;
    const messageDiv = document.createElement('div');
    messageDiv.className = `max-w-[80%] ${isUser ? 'bg-blue-600 text-white' : 'bg-gray-100/90'} rounded-lg p-3 mb-2 shadow`;
    messageDiv.innerHTML = `<p>${content.replace(/\n/g, '<br>')}</p>`;
    
    // ATUALIZADO: Adiciona container de ações para a IA
    if (!isUser) {
        const actionsContainer = document.createElement('div');
        actionsContainer.className = "mt-3 flex items-center gap-4"; // 'gap-4' adiciona espaço entre os botões

        // Botão de Ouvir
        const audioButton = document.createElement('button');
        audioButton.className = "text-blue-800 font-bold underline text-sm";
        audioButton.textContent = "Ouvir";
        audioButton.onclick = () => playAudio(content);
        actionsContainer.appendChild(audioButton);

        // Botão de Copiar
        const copyButton = document.createElement('button');
        copyButton.className = "copy-btn";
        copyButton.textContent = "Copiar";
        copyButton.onclick = function() { copyToClipboard(this); }; // Passa o próprio elemento para a função
        actionsContainer.appendChild(copyButton);
        
        // Elemento de Feedback para Copiar
        const feedbackSpan = document.createElement('span');
        feedbackSpan.className = 'copy-feedback';
        actionsContainer.appendChild(feedbackSpan);

        messageDiv.appendChild(actionsContainer);
    }

    div.appendChild(messageDiv);
    
    // Lógica para renderizar imagem (permanece a mesma)
    if (!isUser && generateImage && imagePrompt && imageUrl) {
        // ... (código de renderização da imagem) ...
    }

    messageHistory.appendChild(div);
    messageHistory.scrollTop = messageHistory.scrollHeight;
}

// --- 5. LÓGICA PRINCIPAL DO CHAT ---
chatForm.addEventListener('submit', async (e) => { /* ... (código igual ao anterior) ... */ });

// --- 6. INICIALIZAÇÃO E EVENTOS ---
document.addEventListener('DOMContentLoaded', () => { /* ... */ });
personaSelect.addEventListener('change', () => { /* ... */ });
clearHistoryBtn.addEventListener('click', () => { /* ... */ });


// --- CÓDIGO COMPLETO DAS FUNÇÕES PARA GARANTIR FUNCIONALIDADE ---
// (Colado aqui para ter um arquivo único e funcional)
const userInput = document.getElementById('userInput');
function saveState() { localStorage.setItem('conversationHistory', JSON.stringify(conversationHistory)); localStorage.setItem('conversationSummary', conversationSummary); localStorage.setItem('lastSummaryIndex', lastSummaryIndex.toString()); localStorage.setItem('lastBackgroundImageUrl', lastBackgroundImageUrl); }
function loadState() { conversationHistory = JSON.parse(localStorage.getItem('conversationHistory')) || []; conversationSummary = localStorage.getItem('conversationSummary') || "A conversa está apenas começando."; lastSummaryIndex = parseInt(localStorage.getItem('lastSummaryIndex')) || 0; lastBackgroundImageUrl = localStorage.getItem('lastBackgroundImageUrl') || ""; updateSummaryDisplay(); }
async function fetchWithTimeout(resource, options = {}, timeout = 25000) { const controller = new AbortController(); options.signal = controller.signal; const timeoutPromise = new Promise((_, reject) => setTimeout(() => { controller.abort(); reject(new Error('A requisição demorou muito e foi cancelada (timeout).')); }, timeout)); return Promise.race([fetch(resource, options), timeoutPromise]); }
function updatePageBackground(imageUrl) { if (!imageUrl) return; const img = new Image(); img.onload = () => { const targetVar = isBackgroundAfterActive ? '--bg-image-before' : '--bg-image-after'; bodyEl.style.setProperty(targetVar, `url(${imageUrl})`); bodyEl.classList.toggle('show-after'); isBackgroundAfterActive = !isBackgroundAfterActive; lastBackgroundImageUrl = imageUrl; saveState(); }; img.onerror = () => console.error("Falha ao carregar a imagem de fundo:", imageUrl); img.src = imageUrl; }
async function createImagePrompt(context) { const artDirectorPrompt = `Você é um diretor de arte... Texto Original: "${context}"`; try { const response = await fetchWithTimeout(`https://text.pollinations.ai/${encodeURIComponent(artDirectorPrompt)}`); if (!response.ok) return context; return (await response.text()).trim(); } catch (error) { console.error("Falha ao criar prompt de imagem:", error); return context; } }
function generateImageUrl(detailedPrompt) { const encodedPrompt = encodeURIComponent(detailedPrompt); return `https://image.pollinations.ai/prompt/${encodedPrompt}?width=1536&height=1024&seed=${Date.now()}&nologo=true&nofeed=true&model=flux`; }
async function playAudio(text) { try { const encodedText = encodeURIComponent(text); const audioUrl = `https://text.pollinations.ai/${encodedText}?model=openai-audio&voice=nova`; const audio = new Audio(audioUrl); audio.play(); } catch (error) { console.error("Erro ao reproduzir áudio:", error); } }
async function updateSummary() { const newMessages = conversationHistory.slice(lastSummaryIndex); if (newMessages.length === 0) return; const newMessagesText = newMessages.map(m => `${m.isUser ? 'Usuário' : 'IA'}: ${m.content}`).join('\n'); const summaryPrompt = `Integre... [Resumo Antigo]: ${conversationSummary} [Mensagens Recentes]: ${newMessagesText} [Novo Resumo Conciso]:`; try { const response = await fetchWithTimeout(`https://text.pollinations.ai/${encodeURIComponent(summaryPrompt)}`); if (response.ok) { conversationSummary = (await response.text()).trim(); lastSummaryIndex = conversationHistory.length; saveState(); updateSummaryDisplay(); } } catch (error) { console.error("Falha ao atualizar o resumo:", error); } }
function updateSummaryDisplay() { summaryDisplay.textContent = conversationSummary; }
function loadChatHistory() { messageHistory.innerHTML = `<div class="text-center text-white font-semibold drop-shadow-md">Início da conversa</div>`; conversationHistory.forEach(msg => renderMessage(msg)); }
chatForm.addEventListener('submit', async (e) => { e.preventDefault(); const userMessageContent = userInput.value.trim(); if (!userMessageContent) return; const userMessageObject = { content: userMessageContent, isUser: true }; conversationHistory.push(userMessageObject); renderMessage(userMessageObject); userInput.value = ''; if (conversationHistory.length - lastSummaryIndex >= 8) { setTimeout(updateSummary, 1000); } const typingDiv = document.createElement('div'); typingDiv.id = 'typingIndicator'; typingDiv.className = 'flex justify-start'; typingDiv.innerHTML = `<div class="bg-gray-100 rounded-lg p-3 shadow"><p id="typingText" class="typing-animation">Gerando resposta...</p></div>`; messageHistory.appendChild(typingDiv); messageHistory.scrollTop = messageHistory.scrollHeight; try { const persona = personaSelect.value === 'custom' ? customPersona.value : predefinedPersonas[personaSelect.value]; const recentHistoryText = conversationHistory.slice(-6).map(m => `${m.isUser ? 'Usuário' : 'IA'}: ${m.content}`).join('\n'); const fullPrompt = `Persona: ${persona}\n\nResumo da Conversa (Memória de Longo Prazo):\n${conversationSummary}\n\nHistórico Recente (Memória de Curto Prazo):\n${recentHistoryText}\n\nUsuário: ${userMessageContent}\n\nIA:`; const response = await fetchWithTimeout(`https://text.pollinations.ai/${encodeURIComponent(fullPrompt)}`); if (!response.ok) throw new Error(`API de texto retornou erro: ${response.statusText}`); const responseText = (await response.text()).trim(); document.getElementById('typingText').textContent = "Criando prompt de imagem..."; const detailedImagePrompt = await createImagePrompt(responseText); document.getElementById('typingText').textContent = "Gerando imagem..."; const imageUrl = generateImageUrl(detailedImagePrompt); updatePageBackground(imageUrl); const aiMessageObject = { content: responseText, isUser: false, generateImage: true, imagePrompt: detailedImagePrompt, imageUrl: imageUrl }; conversationHistory.push(aiMessageObject); renderMessage(aiMessageObject); } catch (error) { console.error("Erro no fluxo do chat:", error); const errorMessage = `Desculpe, ocorreu um erro: ${error.message}. Por favor, tente novamente.`; renderMessage({ content: errorMessage, isUser: false }); } finally { const typingIndicator = document.getElementById('typingIndicator'); if (typingIndicator) typingIndicator.remove(); saveState(); } });
personaSelect.addEventListener('change', () => { customPersona.disabled = personaSelect.value !== 'custom'; if (personaSelect.value !== 'custom') { customPersona.value = predefinedPersonas[personaSelect.value]; } });
clearHistoryBtn.addEventListener('click', () => { if (confirm("Tem certeza que deseja apagar toda a memória e o histórico da conversa?")) { localStorage.clear(); window.location.reload(); } });
document.addEventListener('DOMContentLoaded', () => { loadState(); if (lastBackgroundImageUrl) { bodyEl.style.setProperty('--bg-image-before', `url(${lastBackgroundImageUrl})`); } else { bodyEl.style.setProperty('--bg-image-before', 'linear-gradient(to bottom right, #D1C4E9, #BBDEFB)'); } loadChatHistory(); customPersona.value = ""; userInput.focus(); });
</script>
</body>
</html>

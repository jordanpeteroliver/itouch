<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roleplay AI - Cenário Dinâmico</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- NOVO: Estilos para o Fundo Dinâmico --- */
        body::before,
        body::after {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            z-index: -1;
            background-size: cover;
            background-position: center;
            /* A transição de opacidade cria o efeito de cross-fade */
            transition: opacity 1.5s ease-in-out;
        }

        /* O pseudo-elemento ::before guarda a imagem de fundo atual */
        body::before {
            background-image: var(--bg-image-before);
            opacity: 1;
        }

        /* O pseudo-elemento ::after guarda a próxima imagem e fica invisível */
        body::after {
            background-image: var(--bg-image-after);
            opacity: 0;
        }

        /* Quando esta classe é aplicada ao body, a imagem ::after aparece */
        body.show-after::before { opacity: 0; }
        body.show-after::after { opacity: 1; }
        /* --- Fim dos Estilos de Fundo --- */
        
        .chat-container { height: calc(100vh - 400px); }
        .message-container { max-height: calc(100vh - 500px); }

        .typing-animation::after { content: '...'; animation: typing 1.5s infinite; }
        @keyframes typing { 0% { content: ''; } 25% { content: '.'; } 50% { content: '..'; } 75% { content: '...'; } }

        .image-fade { animation: imageFade 0.7s ease-in-out; }
        @keyframes imageFade { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body class="bg-gradient-to-br from-purple-100 to-blue-100 min-h-screen">
    <!-- O conteúdo da página permanece o mesmo -->
    <div class="container mx-auto p-4 max-w-4xl">
        <header class="text-center mb-6">
            <h1 class="text-3xl font-bold text-blue-800 drop-shadow-md">Roleplay AI - Cenário Dinâmico</h1>
            <p class="text-gray-200 font-semibold drop-shadow-md">O fundo da página agora reflete a última imagem gerada na história.</p>
        </header>

        <div class="bg-white/80 backdrop-blur-sm rounded-lg shadow-lg p-4 mb-4">
             <!-- ... (Restante do HTML da interface é o mesmo) ... -->
        </div>
        <div class="bg-white/80 backdrop-blur-sm rounded-lg shadow-lg chat-container">
            <!-- ... (O HTML do chat é o mesmo) ... -->
        </div>
    </div>

<script>
// --- 1. CONFIGURAÇÕES E ELEMENTOS ---
const bodyEl = document.querySelector('body');
// (Resto das declarações de elementos é o mesmo)

// --- 2. GERENCIAMENTO DE ESTADO E MEMÓRIA ---
let conversationHistory = [];
let conversationSummary = "";
let lastSummaryIndex = 0;
let lastBackgroundImageUrl = ""; // NOVO: Guarda a URL do último fundo
let isBackgroundAfterActive = false; // NOVO: Controla qual pseudo-elemento está ativo

function saveState() {
    localStorage.setItem('conversationHistory', JSON.stringify(conversationHistory));
    localStorage.setItem('conversationSummary', conversationSummary);
    localStorage.setItem('lastSummaryIndex', lastSummaryIndex.toString());
    localStorage.setItem('lastBackgroundImageUrl', lastBackgroundImageUrl); // Salva o fundo
}

function loadState() {
    conversationHistory = JSON.parse(localStorage.getItem('conversationHistory')) || [];
    conversationSummary = localStorage.getItem('conversationSummary') || "A conversa está apenas começando.";
    lastSummaryIndex = parseInt(localStorage.getItem('lastSummaryIndex')) || 0;
    lastBackgroundImageUrl = localStorage.getItem('lastBackgroundImageUrl') || ""; // Carrega o fundo
    updateSummaryDisplay();
}

// --- 3. GERAÇÃO DE IMAGEM, ÁUDIO E **NOVO: FUNDO** ---

/**
 * NOVO: Pré-carrega uma imagem e, ao concluir, a define como o novo fundo
 * da página com uma transição suave.
 * @param {string} imageUrl A URL da imagem a ser carregada.
 */
function updatePageBackground(imageUrl) {
    if (!imageUrl) return;

    // 1. Cria uma imagem em memória para pré-carregamento
    const img = new Image();
    
    img.onload = () => {
        // 2. A imagem foi carregada com sucesso. Agora aplicamos a transição.
        console.log("Imagem de fundo carregada, aplicando transição.");
        
        // Determina qual pseudo-elemento (::before ou ::after) receberá a nova imagem
        const targetVar = isBackgroundAfterActive ? '--bg-image-before' : '--bg-image-after';
        bodyEl.style.setProperty(targetVar, `url(${imageUrl})`);

        // Alterna a classe do body para disparar a transição de opacidade no CSS
        bodyEl.classList.toggle('show-after');
        
        // Atualiza o estado para a próxima transição
        isBackgroundAfterActive = !isBackgroundAfterActive;
        
        // Salva a URL da nova imagem como o fundo mais recente
        lastBackgroundImageUrl = imageUrl;
        saveState();
    };

    img.onerror = () => {
        console.error("Falha ao carregar a imagem de fundo:", imageUrl);
    };

    // 3. Inicia o carregamento da imagem
    img.src = imageUrl;
}

// (Funções createImagePrompt, generateImageUrl, convertTextToAudio, playAudio permanecem as mesmas)

// --- 4. SUMARIZAÇÃO DE MEMÓRIA (Permanece o mesmo) ---

// --- 5. RENDERIZAÇÃO E UI ---

async function renderMessage(messageObject) {
    // (A lógica de renderização da mensagem no chat permanece a mesma)
}

// --- 6. LÓGICA PRINCIPAL DO CHAT ---
chatForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    // ... (Lógica inicial de envio de mensagem do usuário é a mesma) ...

    try {
        // ... (ETAPA 1: Gerar resposta em texto é a mesma) ...
        const responseText = /* ... */;

        // ... (ETAPA 2: Gerar o prompt de imagem detalhado é a mesma) ...
        const detailedImagePrompt = await createImagePrompt(responseText);
        
        document.getElementById('typingText').textContent = "Gerando imagem...";

        const aiMessageObject = { content: responseText, isUser: false, generateImage: true, imagePrompt: detailedImagePrompt };
        
        // ANTES de renderizar a mensagem, nós geramos a URL e iniciamos o carregamento do fundo
        const imageUrl = generateImageUrl(detailedImagePrompt);
        updatePageBackground(imageUrl); // Inicia o processo de atualização do fundo

        // Agora renderizamos a mensagem no chat, que aparecerá quase instantaneamente
        conversationHistory.push(aiMessageObject);
        typingDiv.remove();
        // A função de renderização foi ajustada para receber a URL já gerada
        renderMessage(aiMessageObject, imageUrl); 

    } catch (error) {
        // ... (Tratamento de erro é o mesmo) ...
    } finally {
        // ... (O bloco finally é o mesmo) ...
    }
});

// (Outros event listeners como clearHistoryBtn e personaSelect permanecem os mesmos)

// --- 7. INICIALIZAÇÃO DA PÁGINA ---
document.addEventListener('DOMContentLoaded', () => {
    loadState();
    loadChatHistory();
    
    // NOVO: Aplica o último fundo salvo ao carregar a página
    if (lastBackgroundImageUrl) {
        // Define a imagem inicial diretamente, sem transição na primeira carga
        bodyEl.style.setProperty('--bg-image-before', `url(${lastBackgroundImageUrl})`);
    }

    customPersona.value = "";
    userInput.focus();
});


// ==================================================================
// ============ CÓDIGO COMPLETO DAS SEÇÕES OMITIDAS =================
// ==================================================================
// (Cole o resto do seu JavaScript funcional aqui para garantir que tudo esteja no lugar)
// Incluindo:
// - A declaração completa dos elementos do DOM
// - As funções de áudio, sumarização, renderMessage, etc.

const personaSelect = document.getElementById('personaSelect');
const customPersona = document.getElementById('customPersona');
const clearHistoryBtn = document.getElementById('clearHistoryBtn');
const summaryDisplay = document.getElementById('summaryDisplay');

function updateSummaryDisplay() {
    summaryDisplay.textContent = conversationSummary;
}

async function createImagePrompt(context) {
    const artDirectorPrompt = `Você é um diretor de arte para um motor de geração de imagem. Sua tarefa é converter o texto a seguir em um prompt de imagem detalhado e em inglês, separado por vírgulas. Inclua estilo artístico (ex: fantasy, cyberpunk, photorealistic), iluminação (ex: cinematic lighting, soft morning light), composição, emoção e detalhes ricos. Seja criativo e foque na criação de uma cena visualmente impressionante. Texto Original: "${context}"`;
    try {
        const response = await fetch(`https://text.pollinations.ai/${encodeURIComponent(artDirectorPrompt)}`);
        return response.ok ? (await response.text()).trim() : context;
    } catch (error) {
        console.error("Falha ao criar prompt de imagem:", error);
        return context;
    }
}

function generateImageUrl(detailedPrompt) {
    const encodedPrompt = encodeURIComponent(detailedPrompt);
    return `https://image.pollinations.ai/prompt/${encodedPrompt}?width=1536&height=1024&seed=${Date.now()}&nologo=true&nofeed=true&model=flux`;
}

async function convertTextToAudio(text) {
    const encodedText = encodeURIComponent(text);
    return `https://text.pollinations.ai/${encodedText}?model=openai-audio&voice=nova`;
}

async function playAudio(text) {
    try {
        const audio = new Audio(await convertTextToAudio(text));
        audio.play();
    } catch (error) {
        console.error("Erro ao reproduzir áudio:", error);
    }
}

async function updateSummary() {
    const newMessages = conversationHistory.slice(lastSummaryIndex);
    if (newMessages.length === 0) return;
    const newMessagesText = newMessages.map(m => `${m.isUser ? 'Usuário' : 'IA'}: ${m.content}`).join('\n');
    const summaryPrompt = `Integre as 'Mensagens Recentes' a um 'Resumo Antigo' para criar um 'Novo Resumo Conciso', mantendo fatos importantes (nomes, locais, objetivos, decisões do usuário). [Resumo Antigo]: ${conversationSummary} [Mensagens Recentes]: ${newMessagesText} [Novo Resumo Conciso]:`;
    try {
        const response = await fetch(`https://text.pollinations.ai/${encodeURIComponent(summaryPrompt)}`);
        if (response.ok) {
            conversationSummary = (await response.text()).trim();
            lastSummaryIndex = conversationHistory.length;
            saveState();
            updateSummaryDisplay();
        }
    } catch (error) {
        console.error("Falha ao atualizar o resumo:", error);
    }
}

async function renderMessage(messageObject, generatedImageUrl = null) {
    const { content, isUser, generateImage, imagePrompt } = messageObject;
    const div = document.createElement('div');
    div.className = `flex flex-col ${isUser ? 'items-end' : 'items-start'}`;
    const messageDiv = document.createElement('div');
    messageDiv.className = `max-w-[80%] ${isUser ? 'bg-blue-600 text-white' : 'bg-gray-100/80 backdrop-blur-sm'} rounded-lg p-3 mb-2 shadow`;
    messageDiv.innerHTML = `<p>${content.replace(/\n/g, '<br>')}</p>`;
    if (!isUser) {
        const audioButton = document.createElement('button');
        audioButton.className = "mt-2 text-blue-800 font-bold underline text-sm";
        audioButton.textContent = "Ouvir";
        audioButton.onclick = () => playAudio(content);
        messageDiv.appendChild(audioButton);
    }
    div.appendChild(messageDiv);
    if (!isUser && generateImage && imagePrompt) {
        const imageUrl = generatedImageUrl || generateImageUrl(imagePrompt);
        const imageContainer = document.createElement('div');
        imageContainer.className = 'max-w-full mt-2 image-fade';
        imageContainer.innerHTML = `
            <img src="${imageUrl}" alt="Contexto visual da história" class="rounded-lg shadow-md border">
            <details class="text-xs text-black/80 mt-1 pl-1">
                <summary class="cursor-pointer font-semibold">Ver prompt da imagem</summary>
                <p class="italic p-1 bg-white/50 rounded">${imagePrompt}</p>
            </details>`;
        div.appendChild(imageContainer);
    }
    messageHistory.appendChild(div);
    messageHistory.scrollTop = messageHistory.scrollHeight;
}

function loadChatHistory() {
    messageHistory.innerHTML = '<div class="text-center text-gray-500 font-semibold drop-shadow-md">Início da conversa</div>';
    conversationHistory.forEach(msg => renderMessage(msg));
}

personaSelect.addEventListener('change', () => {
    customPersona.disabled = personaSelect.value !== 'custom';
    if (personaSelect.value !== 'custom') {
        customPersona.value = predefinedPersonas[personaSelect.value];
    }
});

clearHistoryBtn.addEventListener('click', () => {
    if (confirm("Tem certeza que deseja apagar toda a memória e o histórico da conversa? O fundo da página também será resetado.")) {
        localStorage.clear();
        window.location.reload(); // Recarrega a página para um estado limpo
    }
});
</script>
</body>
</html>
